## 先了解一下变量的区分
 - 局部变量
普通局部变量是再熟悉不过的变量了，在任何一个函数内部定义的变量（不加static修饰符）都属于这个范畴。编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的，除非对其显式赋值。
 - 全局变量
全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。
普通全局变量对整个工程可见，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。
静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。
## static关键字的作用范围
 - 修饰局部变量
 Static修饰局部变量会改变局部变量的生命周期，将他的生命周期变为整个进程，且只会定义一次
 - 修饰全局变量
 Static修饰全局变量后，会改变函数的可见性，即即使在外部文件使用extern声明以后，仍然无法调用，仅能在当前文件调用，也就是说该变量的可见性缩小到了当前文件。
 - 修饰函数
Static修饰函数的作用和修饰全局变量相类似，作用相同。
## 具体使用方法
- 修饰局部变量
```c
#include <stdio.h>
int min(){
	static int a = 1;
	while (a<2){
		printf("%d", a);
		a++;
	}
	return  0;
}
int main(){
	//此处直接运行下面的注释行会报错，因为a只是一个局部变量，虽然Static改变了它的生命周期，但是并未改变他的作用域。
	//printf("%d\n", a);
	int c = min();
	int d = min();
	//此时通过调用两次函数min，如果a未被static修饰，则c = d应当是成立的，但被修饰以后，a只会被定义一次，即第二次调用时，a已经时第一次循环后的值，为2，则第二次不会循环
	printf("%d\n%d", c, d);
	return 0;
}
```
- 修饰全局变量
全局变量如果需要在其他文件中调用时仅需使用extern说明即可，但被static修饰的全局变量即使说明后，仍然无法调用，其作用的范围只能是当前文件。
> 文件1 demo1.c
```c
#include <stdio.h>
//此处的a为全局变量
int a = 10;
int main(){
	printf("%d",a);
	return 0;
}
```
> 文件2 demo2.c
```c
#include <stdio.h>
extern a;
int main(){
//在调用文件1中的a变量时仅需extern声明即可调用
	printf("%d",a);
	return 0;
}
```
如上所述，未被修饰的声明即可调用，同理被修饰的则无法被其他文件调用
 - 修饰函数
函数的功能类似全局变量，参考全局变量的用法即可
## 总结
1. 只会改变变量的生命周期，但不会改变作用域
2. 会将变量和函数静态化，只能在当前文件中调用

